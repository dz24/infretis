from infretis.classes.system import System

from abc import ABCMeta, abstractmethod
from pyretis.core.random_gen import create_random_generator
import numpy as np
import logging
logger = logging.getLogger(__name__)
logger.addHandler(logging.NullHandler())

_STATUS = {
    'ACC': 'The path has been accepted',
    'MCR': 'Momenta change rejection',
    'BWI': 'Backward trajectory end at wrong interface',
    'BTL': 'Backward trajectory too long (detailed balance condition)',
    'BTX': 'Backward trajectory too long (max-path exceeded)',
    'BTS': 'Backward trajectory too short',
    'EWI': 'Initial path ends at wrong interface',
    'EXP': 'Exploration path',
    'FTL': 'Forward trajectory too long (detailed balance condition)',
    'FTX': 'Forward trajectory too long (max-path exceeded)',
    'FTS': 'Forward trajectory too short',
    'HAS': 'High Acceptance Swap rejection for SS/WF detailed balance',
    'KOB': 'Kicked outside of boundaries',
    'NCR': 'No crossing with middle interface',
    'NSG': 'Path has no suitable segments',
    'NSS': 'No one-step crossing in stone skipping',
    'SSA': 'Stone Skipping super detailed balance rejection',
    'WFA': 'Wire Fencing super detailed balance rejection',
    'SWI': 'Initial path starts at wrong interface',
    'WTA': 'Web Throwing super detailed balance rejection',
    'TSS': 'Target swap selection rejection',
    'TSA': 'Target swap detailed balance rejection',
    'XSS': 'SS sub path too long in stone skipping',
    '0-L': 'Path in the {0-} ensemble ends at the left interface',
}

_GENERATED = {
    'sh': 'Path was generated with a shooting move',
    'is': 'Path was generated by shooting initially prior to Stone Skipping',
    'tr': 'Path was generated with a time-reversal move',
    'ki': 'Path was generated by integration after kicking',
    're': 'Path was loaded from formatted external file(s)',
    'ld': 'Path was loaded from unformatted external file(s)',
    's+': 'Path was generated by a swapping move from +',
    's-': 'Path was generated by a Swapping move from -',
    'ss': 'Path was generated by Stone Skipping',
    'wt': 'Path was generated by Web Throwing',
    'wf': 'Path was generated by Wire Fencing',
    '00': 'Path was generated by a null move',
    'mr': 'Path was generated by a mirror move',
    'ts': 'Path was generated by a target swap move',
}


# Short versions of the moves:
_GENERATED_SHORT = {
    'sh': 'Shoot',
    'tr': 'Time-reversal',
    'ki': '"Kick" initiation',
    're': 'Formatted ext file load',
    'ld': 'Unformatted ext file load',
    's+': 'Swap from +',
    's-': 'Swap from -',
    'ss': 'Stone skipping',
    'wt': 'Web Throwing',
    'wf': 'Wire Fencing',
    '00': 'Null',
    'mr': 'mirror',
    'ts': 'target swap',
}

class Path:
    """Base class for representation of paths.

    This class represents a path. A path consists of a series of
    consecutive snapshots (the trajectory) with the corresponding order
    parameter.

    Attributes
    ----------
    generated : tuple
        This contains information on how the path was generated.
        `generated[0]` : string, as defined in the variable `_GENERATED`
        `generated[1:]` : additional information:
        For ``generated[0] == 'sh'`` the additional information is the
        index of the shooting point on the old path, the new path and
        the corresponding order parameter.
    maxlen : int
        This is the maximum path length. Some algorithms require this
        to be set. Others don't, which is indicated by setting `maxlen`
        equal to None.
    ordermax : tuple
        This is the (current) maximum order parameter for the path.
        `ordermax[0]` is the value, `ordermax[1]` is the index in
        `self.path`.
    ordermin : tuple
        This is the (current) minimum order parameter for the path.
        `ordermin[0]` is the value, `ordermin[1]` is the index in
        `self.path`.
    phasepoints : list of objects like :py:class:`.System`
        The phase points the path is made up of.
    rgen : object like :py:class:`.RandomGenerator`
        This is the random generator that will be used for the
        paths that required random numbers.
    time_origin : int
        This is the location of the phase point `path[0]` relative to
        its parent. This might be useful for plotting.
    status : str or None
        The status of the path. The possibilities are defined
        in the variable `_STATUS`.
    weight : real
        The statistical weight of the path.

    """

    def __init__(self, rgen=None, maxlen=None, time_origin=0):
        """Initialise the PathBase object.

        Parameters
        ----------
        rgen : object like :py:class:`.RandomGenerator`, optional
            This is the random generator that will be used.
        maxlen : int, optional
            This is the max-length of the path. The default value,
            None, is just a path of arbitrary length.
        time_origin : int, optional
            This can be used to store the shooting point of a parent
            trajectory.

        """
        self.maxlen = maxlen
        self.weight = 1.
        self.time_origin = time_origin
        self.status = None
        self.generated = None
        self.phasepoints = []
        self.path_number = None
        self.traj_v = None
        if rgen is None:
            rgen = create_random_generator()
        self.rgen = rgen

    @property
    def length(self):
        """Compute the length of the path."""
        return len(self.phasepoints)

    @property
    def ordermin(self):
        """Compute the minimum order parameter of the path."""
        idx = np.argmin([i.order[0] for i in self.phasepoints])
        return (self.phasepoints[idx].order[0], idx)

    @property
    def ordermax(self):
        """Compute the maximum order parameter of the path."""
        idx = np.argmax([i.order[0] for i in self.phasepoints])
        return (self.phasepoints[idx].order[0], idx)

    def check_interfaces(self, interfaces):
        """Check current status of the path.

        Get the current status of the path with respect to the
        interfaces. This is intended to determine if we have crossed
        certain interfaces or not.

        Parameters
        ----------
        interfaces : list of floats
            This list is assumed to contain the three interface values
            left, middle and right.

        Returns
        -------
        out[0] : str, 'L' or 'R' or None
            Start condition: did the trajectory start at the left ('L')
            or right ('R') interface.
        out[1] : str, 'L' or 'R' or None
            Ending condition: did the trajectory end at the left ('L')
            or right ('R') interface or None of them.
        out[2] str, 'M' or '*'
            'M' if the middle interface is crossed, '*' otherwise.
        out[3] : list of boolean
            These values are given by
            `ordermin < interfaces[i] <= ordermax`.

        """
        if self.length < 1:
            logger.warning('Path is empty!')
            return None, None, None, None
        ordermax, ordermin = self.ordermax[0], self.ordermin[0]
        cross = [ordermin < interpos <= ordermax for interpos in interfaces]
        left, right = min(interfaces), max(interfaces)
        # Check end & start point:
        end = self.get_end_point(left, right)
        start = self.get_start_point(left, right)
        middle = 'M' if cross[1] else '*'
        return start, end, middle, cross

    def get_end_point(self, left, right=None):
        """Return the end point of the path as a string.

        The end point is either to the left of the `left` interface or
        to the right of the `right` interface, or somewhere in between.

        Parameters
        ----------
        left : float
            The left interface.
        right : float, optional
            The right interface, equal to left if not specified.

        Returns
        -------
        out : string
            A string representing where the end point is ('L' - left,
            'R' - right or None).

        """
        if right is None:
            right = left
        assert left <= right

        if self.phasepoints[-1].order[0] <= left:
            end = 'L'
        elif self.phasepoints[-1].order[0] >= right:
            end = 'R'
        else:
            end = None
            logger.debug('Undefined end point.')
        return end

    def get_start_point(self, left, right=None):
        """Return the start point of the path as a string.

        The start point is either to the left of the `left` interface or
        to the right of the `right` interface.

        Parameters
        ----------
        left : float
            The left interface.
        right : float, optional
            The right interface, equal to left if not specified.

        Returns
        -------
        out : string
            A string representing where the start point is ('L' - left,
            'R' - right or None).

        """
        if right is None:
            right = left
        assert left <= right
        if self.phasepoints[0].order[0] <= left:
            start = 'L'
        elif self.phasepoints[0].order[0] >= right:
            start = 'R'
        else:
            start = None
            logger.debug('Undefined starting point.')
        return start

    def get_shooting_point(self, criteria='rnd', interfaces=None):
        """Return a shooting point from the path.

        This will simply draw a shooting point from the path at
        random. All points can be selected with equal probability with
        the exception of the end points which are not considered.

        Parameters
        ----------
        criteria : string, optional
            The criteria to select the shooting point:
            'rnd': random, except the first and last point, standard sh.
            'exp': selection towards low density region.
        list/tuple of floats, optional
          These are the interface positions of the form
          ``[left, middle, right]``.

        Returns
        -------
        out[0] : object like :py:class:`.System`
            The phase point we selected.
        out[1] : int
            The shooting point index.

        """
        keep_list = []
        rnd_idx = self.rgen.random_integers(1, self.length - 2)

        # The method is not done to be working on the 0^- ensemble.
        if criteria == 'exp' and interfaces[0] != float('-inf'):
            n_slabs = 42
            hyst = [0]*n_slabs
            for p_p in self.phasepoints:
                idx = abs(int((p_p.order[0] - interfaces[0]) /
                              (interfaces[-1] - interfaces[0])*n_slabs))
                hyst[idx] += 1

            # Exclude the extremis, no much interesting and always low value
            for i in [0, 1, 2, -3, -2, -1]:
                hyst[i] = max(hyst)

            # find the not zero minimum
            h_min = hyst.index(min(hyst))
            while hyst[h_min] == 0:
                hyst[h_min] = max(hyst)
                h_min = hyst.index(min(hyst))

            for idx, p_p in enumerate(self.phasepoints):
                i_slab = abs(int((p_p.order[0] - interfaces[0]) /
                                 (interfaces[-1] - interfaces[0])*n_slabs))
                if i_slab == h_min:
                    keep_list.append(idx)

        idx = rnd_idx if len(keep_list) < 4 else keep_list[
            self.rgen.random_integers(1, len(keep_list) - 2)]

        logger.debug("Selected point with orderp %s",
                     self.phasepoints[idx].order[0])
        return self.phasepoints[idx], idx

    @abstractmethod
    def phasepoint(self, idx):
        """Return a specific phase point.

        Parameters
        ----------
        idx : int
            Index for phase-space point to return.

        Returns
        -------
        out : tuple
            A phase-space point in the path.

        """
        return

    @abstractmethod
    def _append_posvel(self, pos, vel):
        """Append positions and velocities to the path."""
        return

    def append(self, phasepoint):
        """Append a new phase point to the path.

        Parameters
        ----------
        out : object like :py:class:`.System`
            The system information we add to the path.

        """
        if self.maxlen is None or self.length < self.maxlen:
            self.phasepoints.append(phasepoint)
            return True
        logger.debug('Max length exceeded. Could not append to path.')
        return False

    def get_path_data(self, status, interfaces):
        """Return information about the path.

        This information can be stored in a object like
        :py:class:`.PathEnsemble`.

        Parameters
        ----------
        status : string
            This represents the current status of the path.
        interfaces : list
            These are just the interfaces we are currently considering.

        """
        path_info = {
            'generated': self.generated,
            'status': status,
            'length': self.length,
            'ordermax': self.ordermax,
            'ordermin': self.ordermin,
            'weight': self.weight,
        }

        start, end, middle, _ = self.check_interfaces(interfaces)
        path_info['interface'] = (start, middle, end)

        return path_info

    def set_move(self, move):
        """Update the path move.

        The path move is a short string that represents how the path
        was generated. It should preferably match one of the moves
        defined in `_GENERATED`.

        Parameters
        ----------
        move : string
            A short description of the move.

        """
        if self.generated is None:
            self.generated = (move, 0, 0, 0)
        else:
            self.generated = (move, self.generated[1], self.generated[2],
                              self.generated[3])

    def get_move(self):
        """Return the move used to generate the path."""
        if self.generated is None:
            return None
        return self.generated[0]

    def success(self, target_interface):
        """Check if the path is successful.

        The check is based on the maximum order parameter and the value
        of `target_interface`. It is successful if the maximum order parameter
        is greater than `target_interface`.

        Parameters
        ----------
        target_interface : float
            The value for which the path is successful, i.e. the
            "target_interface" interface.

        """
        return self.ordermax[0] > target_interface

    def __iadd__(self, other):
        """Add path data to a path from another path, i.e. ``self += other``.

        This will simply append the phase points from `other`.

        Parameters
        ----------
        other : object of type `Path`
            The object to add path data from.

        Returns
        -------
        self : object of type `Path`
            The updated path object.

        """
        for phasepoint in other.phasepoints:
            app = self.append(phasepoint.copy())
            if not app:
                logger.warning(
                    'Truncated path at %d while adding paths', self.length
                )
                return self
        return self

    def copy(self):
        """Return a copy of the path."""
        new_path = self.empty_path()
        for phasepoint in self.phasepoints:
            new_path.append(phasepoint.copy())
        new_path.status = self.status
        new_path.time_origin = self.time_origin
        new_path.generated = self.generated
        new_path.maxlen = self.maxlen
        new_path.weight = self.weight
        new_path.path_number = self.path_number
        new_path.traj_v = self.traj_v
        return new_path

    def reverse_velocities(self):
        """Reverse the velocities in the system."""
        self.vel_rev = not self.vel_rev

    def reverse(self, order_function=False, rev_v=True):
        """Reverse a path and return the reverse path as a new path.

        This will reverse a path and return the reversed path as
        a new object like :py:class:`.PathBase` object.

        Returns
        -------
        new_path : object like :py:class:`.PathBase`
            The time reversed path.
        order_function : object like :py:class:`.OrderParameter`, optional
            The method to use to re-calculate the order parameter,
            if it is velocity dependent.
        rev_v : boolean, optional
            If True, also the velocities are reversed, if False, the velocities
            for each frame are not altered.

        """
        new_path = self.empty_path()
        new_path.weight = self.weight
        new_path.maxlen = self.maxlen
        for phasepoint in reversed(self.phasepoints):
            new_point = phasepoint.copy()
            if rev_v:
                self.reverse_velocities(new_point)
            app = new_path.append(new_point)
            if not app:  # pragma: no cover
                msg = 'Could not reverse path'
                logger.error(msg)
                return None
        if order_function and order_function.velocity_dependent and rev_v:
            for phasepoint in new_path.phasepoints:
                phasepoint.order = order_function.calculate(phasepoint)
        return new_path

    def __str__(self):
        """Return a simple string representation of the Path."""
        msg = ['Path with length {} (max: {})'.format(self.length,
                                                      self.maxlen)]
        msg += ['Order parameter max: {}'.format(self.ordermax)]
        msg += ['Order parameter min: {}'.format(self.ordermin)]
        if self.length > 0:
            msg += ['Start {}'.format(self.phasepoints[0].order[0])]
            msg += ['End {}'.format(self.phasepoints[-1].order[0])]
        if self.status:
            msg += ['Status: {}'.format(_STATUS[self.status])]
        if self.generated:
            move = self.generated[0]
            txtmove = _GENERATED.get(move, 'unknown move')
            msg += ['Generated: {}'.format(txtmove)]
            msg += ['Weight: {}'.format(self.weight)]
        return '\n'.join(msg)

    def restart_info(self):
        """Return a dictionary with restart information."""
        info = {
            'rgen': self.rgen.get_state(),
            'generated': self.generated,
            'maxlen': self.maxlen,
            'time_origin': self.time_origin,
            'status': self.status,
            'weight': self.weight,
            'phasepoints': [i.restart_info() for i in self.phasepoints]
        }
        return info

    def load_restart_info(self, info):
        """Set up the path using restart information."""
        for key, val in info.items():
            # For phasepoints, create new System objects
            # and load the information for these.
            # The snaps still need to forcefield to be re-initiated.
            if key == 'phasepoints':
                for point in val:
                    system = System()
                    system.load_restart_info(point)
                    self.append(system)
            elif key == 'rgen':
                self.rgen = create_random_generator(info['rgen'])
            else:
                if hasattr(self, key):
                    setattr(self, key, val)

    def empty_path(self, **kwargs):
        """Return an empty path of same class as the current one.

        Returns
        -------
        out : object like :py:class:`.PathBase`
            A new empty path.

        """
        maxlen = kwargs.get('maxlen', None)
        time_origin = kwargs.get('time_origin', 0)
        return self.__class__(self.rgen, maxlen=maxlen,
                              time_origin=time_origin)

    def __eq__(self, other):
        """Check if two paths are equal."""
        if self.__class__ != other.__class__:
            logger.debug('%s and %s.__class__ differ', self, other)
            return False

        if set(self.__dict__) != set(other.__dict__):
            logger.debug('%s and %s.__dict__ differ', self, other)
            return False

        # Compare phasepoints:
        if not len(self.phasepoints) == len(other.phasepoints):
            return False
        for i, j in zip(self.phasepoints, other.phasepoints):
            if not i == j:
                return False
        if self.phasepoints:
            # Compare other attributes:
            for i in ('maxlen', 'time_origin', 'status', 'generated',
                      'length', 'ordermax', 'ordermin'):
                attr_self = hasattr(self, i)
                attr_other = hasattr(other, i)
                if attr_self ^ attr_other:  # pragma: no cover
                    logger.warning('Failed comparing path due to missing "%s"',
                                   i)
                    return False
                if not attr_self and not attr_other:
                    logger.warning(
                        'Skipping comparison of missing path attribute "%s"',
                        i)
                    continue
                if getattr(self, i) != getattr(other, i):
                    return False
        return True

    def __ne__(self, other):
        """Check if two paths are not equal."""
        return not self == other

    def delete(self, idx):
        """Remove a phase point from the path.

        Parameters
        ----------
        idx : integer
            The index of the frame to remove.

        """
        del self.phasepoints[idx]

    def sorting(self, key, reverse=False):
        """Re-order the phase points according to the given key.

        Parameters
        ----------
        key : string
            The attribute we will sort according to.
        reverse : boolean, optional
            If this is False, the sorting is from big to small.

        Yields
        ------
        out : object like :py:class:`.System`
            The ordered phase points from the path.

        """
        if key in ('ekin', 'vpot'):
            sort_after = [getattr(i.particles, key) for i in self.phasepoints]
        elif key == 'order':
            sort_after = [getattr(i, key)[0] for i in self.phasepoints]
        else:
            sort_after = [getattr(i, key) for i in self.phasepoints]
        idx = np.argsort(sort_after)
        if reverse:
            idx = idx[::-1]
        self.phasepoints = [self.phasepoints[i] for i in idx]

    def update_energies(self, ekin, vpot):
        """Update the energies for the phase points.

        This method is useful in cases where the energies are
        read from external engines and returned as a list of
        floats.

        Parameters
        ----------
        ekin : list of floats
            The kinetic energies to set.
        vpot : list of floats
            The potential energies to set.

        """
        if len(ekin) != len(vpot):
            logger.debug(
                'Kinetic and potential energies have different length.'
            )
        if len(ekin) != len(self.phasepoints):
            logger.debug(
                'Length of kinetic energy and phase points differ %d != %d.',
                len(ekin), len(self.phasepoints)
            )
        if len(vpot) != len(self.phasepoints):
            logger.debug(
                'Length of potential energy and phase points differ %d != %d.',
                len(vpot), len(self.phasepoints)
            )
        for i, phasepoint in enumerate(self.phasepoints):
            try:
                vpoti = vpot[i]
            except IndexError:
                logger.warning(
                    'Ran out of potential energies, setting to None.'
                )
                vpoti = None
            try:
                ekini = ekin[i]
            except IndexError:
                logger.warning(
                    'Ran out of kinetic energies, setting to None.'
                )
                ekini = None
            phasepoint.particles.vpot = vpoti
            phasepoint.particles.ekin = ekini
